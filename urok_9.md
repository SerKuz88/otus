# otus
1.Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.  
до настроек:  
![image](https://user-images.githubusercontent.com/108919955/184071002-6c11dfa3-08b2-4f73-83c6-e76e182ed10d.png)  
  
после настроек:  
![image](https://user-images.githubusercontent.com/108919955/184072158-c42685b0-b216-462b-a72c-946fc2008f27.png)  
  
 пример:  
 первая сессия  
 ![image](https://user-images.githubusercontent.com/108919955/184470550-46e327a1-bfb2-430d-86d8-d2268c8818c7.png)
 вторая сессия  
 ![image](https://user-images.githubusercontent.com/108919955/184470610-2fa87ff6-9834-4a30-8e72-eedeee5a42d2.png)

  
2.Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.  
3.Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?  
4.Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?  
5.Попробуйте воспроизвести такую ситуацию.  


